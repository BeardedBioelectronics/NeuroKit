{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EEG Microstates"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In continually recorded human EEG, the spatial distribution of electric potentials across the cortex changes over time. Interestingly, for brief time periods (60 - 120ms), quasi-stable states of activity (i.e., **microstates**), characterized by unique spatial configurations of electrical activity distribution, have been observed. NeuroKit can be used to easily analyze them."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load the NeuroKit package and other useful packages\n",
    "import neurokit2 as nk\n",
    "import matplotlib.pyplot as plt\n",
    "import mne\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# This cell is hidden using the \"hide-input\" tag.\n",
    "plt.rcParams['figure.figsize'] = [15, 5]  # Bigger images\n",
    "plt.rcParams['font.size']= 14"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## EEG Preprocessing"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First, let's download a raw eeg data in an [MNE](https://mne.tools/stable/index.html) format. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "raw = nk.data(\"eeg_1min_200hz\")\n",
    "# sampling_rate = raw.info[\"sfreq\"]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "EEG recordings measure the difference in electric potential between each electrode and a reference electrode. This means that the ideal reference electrode is one which records **all** the interfering noise from the environment but doesn't pick up any fluctuating signals related to brain activity. The idea behind re-referencing is to express the voltage at the EEG scalp channels with respect to another, new reference. This \"virtual reference\" can be any recorded channel, or the average of all the channels, as we will use in the current analysis.\n",
    "\n",
    "Below, we will apply a band-pass filter and re-reference the signals to remove power line noise, slow drifts and other large artifacts from the raw input."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# # Apply band-pass filter (1-35Hz) and re-reference the raw signal\n",
    "# eeg = raw.copy().filter(1, 35, verbose = False)\n",
    "# eeg = nk.eeg_rereference(eeg, 'average')\n",
    "\n",
    "# nk.signal_plot([raw.get_data()[0, 0:500], eeg.get_data()[0, 0:500]], \n",
    "#                labels =[\"Raw\", \"Preprocessed\"], \n",
    "#                sampling_rate = eeg.info[\"sfreq\"])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Microstates Analysis"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Minimal Example\n",
    "\n",
    "Microstates can be extracted and analyzed like that:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# # Extract microstates\n",
    "# microstates = nk.microstates_segment(eeg, n_microstates=4)\n",
    "\n",
    "# # Visualize the extracted microstates\n",
    "# nk.microstates_plot(microstates, epoch = (0, 500))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This shows the aspect of the microstates and their sequence in the Global Field Power (GFP; see below). We can then proceed to a statistical analysis."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# nk.microstates_static(microstates, sampling_rate=sampling_rate, show=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This shows computes static statistics, such as the prevalence of each microstates and the median duration time (also shown in the graph)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# nk.microstates_dynamic(microstates, show=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, one can compute complexity features of the sequence of microstates, such as the entropy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "# nk.microstates_complexity(microstates, show=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Options and features"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Global Field Power (GFP)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Under the hood, `microstates_segment()` starts by computing the GFP.\n",
    "\n",
    "The Global Field Power (GFP) is a reference-independent measure of potential field strength. It is thought to quantify the integrated electrical activity of the brain and is mathematically defined as the standard deviation of all electrodes at a given time. \n",
    "\n",
    "The GFP time series periodically shows peaks, where the EEG topographies are most clearly defined (i.e., signal-to-noise ratio is maximized at GFP peaks). As such, GFP peak samples are often used to extract microstates.\n",
    "\n",
    "This can be visualized manually:\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "# gfp = nk.eeg_gfp(eeg)\n",
    "\n",
    "# peaks = nk.microstates_peaks(eeg, gfp=gfp)\n",
    "\n",
    "# # Plot the peaks in the first 200 data points\n",
    "# nk.events_plot(events = peaks[peaks < 200], signal = gfp[0:200])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "By default, the microstates clustering algorithm is **trained** on the EEG activity at these peaks, and then applied to back-predict the state at all data points. However, this behaviour can be changed. For instance, one can decide to train the algorithm directly on all data points."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "# microstates_all = nk.microstates_segment(eeg, n_microstates=4, train=\"all\")\n",
    "# nk.microstates_plot(microstates_all, epoch = (0, 500))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### How many microstates?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Most of the clustering algorithms used in microstates analysis require the number of clusters to extract to be specified beforehand. \n",
    "\n",
    "However, one can attempt at statistically estimating the optimal number of microstates. A variety of indices of fit can be used."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "# n_optimal, scores = nk.microstates_findnumber(eeg, n_max=8, show=True)\n",
    "# print(\"Optimal number of microstates: \", n_optimal)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Microstates clustering algorithms"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Several different clustering algorithms can be used to segment your EEG recordings into microstates. These algorithms mainly differ in how they define cluster membership and the cost functionals to be optimized ([Xu & Tian, 2015](10.1007/s40745-015-0040-1)). The method to use hence depends on your data and the underlying assumptions of the methods (e.g., some methods ignore polarity). There is no one true method that gives the best results but you can refer to [Poulsen et al., 2018](https://www.researchgate.net/publication/331367421_Microstate_EEGlab_toolbox_An_introductory_guide#pf6) if you would like a more detailed review of the different clustering methods."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In the example below, we will compare the two most commonly applied clustering algorithms - the *K-means* and *modified K-means*. Other methods that can be applied using `nk.microstates_segment` include `kmedoids, pca, ica, aahc`. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "# # Extract microstates\n",
    "# microstates_kmeans = nk.microstates_segment(eeg, n_microstates=4, method=\"kmeans\")\n",
    "# microstates_kmod = nk.microstates_segment(eeg, n_microstates=4, method=\"kmod\")  \n",
    "\n",
    "# # Global Explained Variance\n",
    "# gev_kmeans = microstates_kmeans['GEV']\n",
    "# gev_kmod = microstates_kmod['GEV']\n",
    "# print( f' Using conventional Kmeans,  GEV = {gev_kmeans*100:.2f}%')\n",
    "# print( f' Using modified Kmeans,  GEV = {gev_kmod*100:.2f}%')\n",
    "\n",
    "# # Visualize the extracted microstates\n",
    "# nk.microstates_plot(microstates_kmeans, epoch = (150, 450))\n",
    "# nk.microstates_plot(microstates_kmod, epoch = (150, 450))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.9.7 64-bit",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  },
  "orig_nbformat": 4,
  "vscode": {
   "interpreter": {
    "hash": "11938c6bc6919ae2720b4d5011047913343b08a43b18698fd82dedb0d4417594"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
